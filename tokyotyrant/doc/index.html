<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Language" content="en" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Script-Type" content="text/javascript" />
<meta name="author" content="Mikio Hirabayashi" />
<meta name="keywords" content="Tokyo Tyrant, tokyotyrant, Tokyo Cabinet, database, DBM" />
<meta name="description" content="specifications of Tokyo Tyrant" />
<link rel="contents" href="./" />
<link rev="made" href="mailto:mikio@users.sourceforge.net" />
<title>Tokyo Tyrant: network interface of Tokyo Cabinet</title>
<style type="text/css">html {
  margin: 0em 0em;
  padding: 0em 0em;
  background: #eeeeee none;
}
body {
  margin: 1em 2em;
  padding: 0em 0em;
  background: #eeeeee none;
  color: #111111;
}
hr {
  margin: 2.5em 0em 1.5em 0em;
  height: 1px;
  border: none;
  background: #999999 none;
  color: #999999;
}
h1,h2,h3,h4,h5,h6 {
  font-weight: bold;
}
h1 {
  margin: 1.0em 0em 1.3em 0em;
  padding: 0em 0em;
  font-size: 180%;
  color: #000000;
}
h2 {
  margin: 1.0em 0em 1.0em 0.2em;
  padding: 0.5em 0.5em;
  width: 60%;
  border-left: solid 0.6em #445555;
  border-bottom: solid 1px #bbbbbb;
  font-size: 150%;
  color: #000011;
}
h3 {
  margin: 0.8em 0em 0.5em 0.2em;
  padding: 0em 0em;
  font-size: 120%;
  color: #001111;
}
p {
  margin: 0.8em 0em;
  line-height: 140%;
  text-indent: 0.8em;
}
div,pre,table {
  margin: 0.8em 1.5em;
}
div.note,div.navi {
  text-align: right;
  margin: 0em 0.5em;
  color: #333333;
}
span.void {
  color: #888888;
}
div.logo {
  text-align: center;
  margin: 3em 0em;
}
div.logo img {
  border: inset 2px #ccccdd;
}
div.illust {
  margin: 1em 0em;
  text-align: center;
}
div.illust img {
  border: solid 1px #ccccdd;
}
pre {
  padding: 0.2em;
  background-color: #ddddee;
  border: 1px solid #bbbbcc;
  font-size: 95%;
}
li,dt,dd {
  line-height: 130%;
}
dt {
  margin-left: 1.2em;
}
dd {
  margin-left: 2.5em;
  text-indent: -0.3em;
}
dl.api {
  margin-top: -0.2em;
}
dl.api dd {
  margin-left: 3.0em;
  font-size: 95%;
  color: #333333;
}
ul {
  margin: 0.5em 2.0em;
  padding: 0em;
}
ul.options {
  list-style-type: none;
  margin: 0.5em 1.5em;
  font-size: 95%;
  color: #333333;
}
table {
  border-collapse: collapse;
}
td {
  text-align: left;
  vertical-align: top;
  padding: 0.1em 0.5em;
  border: solid 1px #aaaabb;
  font-size: 95%;
}
td.label {
  border: none;
  font-size: 80%;
  color: #333333;
}
td.number {
  text-align: right;
}
a {
  color: #0022aa;
  text-decoration: none;
}
a:hover,a:focus {
  color: #0033ee;
  text-decoration: underline;
}
code,kbd {
  font-style: normal;
  font-weight: bold;
  font-size: 100%;
  color: #001111;
}
var {
  padding: 0em 0.15em 0em 0em;
  font-style: italic;
  color: #001122;
}
</style>
</head>

<body>

<h1 id="headline">Tokyo Tyrant: network interface of Tokyo Cabinet</h1>

<div class="note">Copyright (C) 2007-2008 Mikio Hirabayashi</div>
<div class="note">Last Update: Wed, 30 Jul 2008 16:31:42 +0900</div>

<hr />

<h2 id="contents">Table of Contents</h2>

<ol>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#serverprog">The Server Programs</a></li>
<li><a href="#clientprog">The Client Programs</a></li>
<li><a href="#tcrdbapi">The Remote Database API</a></li>
<li><a href="#protocol">Protocol</a></li>
<li><a href="#tutorial">Tutorial</a></li>
<li><a href="#license">License</a></li>
</ol>

<hr />

<h2 id="introduction">Introduction</h2>

<p>Tokyo Tyrant is a package of network interface to the DBM called Tokyo Cabinet.  Though the DBM has high performance, you might bother in case that multiple processes share the same database, or remote processes access the database.  Thus, Tokyo Tyrant is provided for concurrent and remote connections to Tokyo Cabinet.  It is composed of the server process managing a database and its access library for client applications.</p>

<p>The server features high concurrency due to thread-pool modeled implementation and the epoll/kqueue mechanism of the modern Linux/*BSD kernel.  The server and its clients communicate with each other by simple binary protocol on TCP/IP.  Protocols compatible with memcached and HTTP/1.1 are also supported so that almost all principal platforms and programming languages can use Tokyo Tyrant.  High availability and high integrity are also featured due to hot such mechanisms as hot backup, update logging, and replication.</p>

<p><em>As for now, the server works on Linux, FreeBSD, Mac OS X only.</em></p>

<hr />

<h2 id="installation">Installation</h2>

<p>Install the latest version of Tokyo Cabinet beforehand and get the package of Tokyo Tyrant.</p>

<p>When an archive file of Tokyo Tyrant is extracted, change the current working directory to the generated directory and perform installation.</p>

<p>Run the configuration script.</p>

<pre>./configure
</pre>

<p>Build programs.</p>

<pre>make
</pre>

<p>Install programs.  This operation must be carried out by the root user.</p>

<pre>make install
</pre>

<p>When a series of work finishes, the following files will be installed.</p>

<pre>/usr/local/include/ttutil.h
/usr/local/include/tculog.h
/usr/local/include/tcrdb.h
/usr/local/lib/libtokyotyrant.a
/usr/local/lib/libtokyotyrant.so.1.17.0
/usr/local/lib/libtokyotyrant.so.1
/usr/local/lib/libtokyotyrant.so
/usr/local/lib/pkgconfig/tokyotyrant.pc
/usr/local/bin/ttserver
/usr/local/bin/ttultest
/usr/local/bin/ttulmgr
/usr/local/bin/tcrtest
/usr/local/bin/tcrmttest
/usr/local/bin/tcrmgr
/usr/local/sbin/ttservctl
/usr/local/share/tokyotyrant/...
/usr/local/man/man1/...
/usr/local/man/man3/...
</pre>

<p>To test the server, perform the following command.  To finish it, press Ctrl-C on the terminal.</p>

<pre>ttserver
</pre>

<p>To test the client connecting to the above running server, perform the following command on another terminal.</p>

<pre>make check
</pre>

<hr />

<h2 id="serverprog">The Server Programs</h2>

<h3>ttserver</h3>

<p>The command `<code>ttserver</code>' runs the server managing a database instance.  Because the database is treated by the abstract API of Tokyo Cabinet, you can choose the scheme on start-up of the server.  Supported schema are on-memory database, hash database, and B+ tree database.  This command is used in the following format.  `<var>dbname</var>' specifies the database name.  If it is omitted, on-memory database is specified.</p>

<dl class="api">
<dt><code>ttserver [-host <var>name</var>] [-port <var>num</var>] [-th<var>num</var> <var>num</var>] [-tout <var>num</var>] [-dmn] [-pid <var>path</var>] [-log <var>path</var>] [-ld|-le] [-ulog <var>path</var>] [-ulim <var>num</var>] [-uas] [-sid <var>num</var>] [-mhost <var>name</var>] [-mport <var>num</var>] [-rts <var>path</var>] [<var>dbname</var>]</code></dt>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-host <var>name</var></code> : specify the host name or the address of the server.  By default, every network address is bound.</li>
<li><code>-port <var>num</var></code> : specify the port number.  By default, it is 1978.</li>
<li><code>-thnum <var>num</var></code> : specify the number of worker threads.  By default, it is 8.</li>
<li><code>-tout <var>num</var></code> : specify the timeout of each session in seconds.  By default, no timeout is specified.</li>
<li><code>-dmn</code> : work as a daemon process.</li>
<li><code>-pid <var>path</var></code> : output the process ID into the file.</li>
<li><code>-log <var>path</var></code> : output log messages into the file.</li>
<li><code>-ld</code> : log debug messages also.</li>
<li><code>-le</code> : log error messages only.</li>
<li><code>-ulog <var>path</var></code> : specify the update log directory.</li>
<li><code>-ulim <var>num</var></code> : specify the limit size of each update log file.</li>
<li><code>-uas</code> : use asynchronous I/O for the update log.</li>
<li><code>-sid <var>num</var></code> : specify the server ID.</li>
<li><code>-mhost <var>name</var></code> : specify the host name of the replication master server.</li>
<li><code>-mport <var>num</var></code> : specify the port number of the replication master server.</li>
<li><code>-rts <var>path</var></code> : specify the replication time stamp file.</li>
</ul>

<p>To terminate the server normally, send SIGINT or SIGTERM to the process.  It is okay to press Ctrl-C on the controlling terminal.  To restart the server, send SIGHUP to the process.  If the port number is not more than 0, UNIX domain socket is used and the path of the socket file is specified by the host parameter.  This command returns 0 on success, another on failure.</p>

<p>The naming convention of the database is specified by the abstract API of Tokyo Cabinet.  If the name is "*", the database will be an on-memory database.  If its suffix is ".tch", the database will be a hash database.  If its suffix is ".tcb", the database will be a B+ tree database.  If its suffix is ".tcf", the database will be a fixed-length database.  Otherwise, this function fails.  Tuning parameters can trail the name, separated by "#".  Each parameter is composed of the name and the number, separated by "=".  On-memory database supports "bnum", "capnum", and "capsiz".  Hash database supports "mode", "bnum", "apow", "fpow", "opts", "rcnum", and "xmsiz".  B+ tree database supports "mode", "lmemb", "nmemb", "bnum", "apow", "fpow", "opts", "lcnum", "ncnum", and "xmsiz".  Fixed-length database supports "mode", "width", and "limsiz".  "capnum" specifies the capacity number of records.  "capsiz" specifies the capacity size of using memory.  Records spilled the capacity are removed by the storing order.  "mode" can contain "w" of writer, "r" of reader, "c" of creating, "t" of truncating, "e" of no locking, and "f" of non-blocking lock.  The default mode is relevant to "wc".  "opts" can contains "l" of large option, "d" of Deflate option, "b" of BZIP2 option, and "t" of TCBS option.  For example, "casket.tch#bnum=1000000#opts=ld" means that the name of the database file is "casket.tch", and the bucket number is 1000000, and the options are large and Deflate.</p>

<h3>ttservctl</h3>

<p>The command `<code>ttservctl</code>' is the startup script of the server.  It can be called by the RC script of the bootstrap process of the operating system.  This command is used in the following format.</p>

<dl class="api">
<dt><code>ttservctl start</code></dt>
<dd>Startup the server.</dd>
<dt><code>ttservctl stop</code></dt>
<dd>Stop the server.</dd>
<dt><code>ttservctl restart</code></dt>
<dd>Restart the server.</dd>
<dt><code>ttservctl hup</code></dt>
<dd>Send HUP signal to the server for log rotation.</dd>
</dl>

<p>The database is placed as "/var/ttserver/casket.tch".  The log and related files are also placed in "/var/ttserver".  This command returns 0 on success, another on failure.</p>

<h3>ttulmgr</h3>

<p>The command `<code>ttulmgr</code>' is the utility to export and import the update log.  It is useful to filter the update log with such text utilities as `<code>grep</code>' and `<code>sed</code>'.  This command is used in the following format.  `<var>upath</var>' specifies the update log directory.</p>

<dl class="api">
<dt><code>ttulmgr export [-ts <var>num</var>] [-sid <var>num</var>] <var>upath</var></code></dt>
<dd>Export the update log as TSV text data to the standard output.</dd>
<dt><code>ttulmgr import <var>upath</var></code></dt>
<dd>Import TSV text data from the standard input to the update log.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-ts <var>num</var></code> : specify the beginning time stamp.</li>
<li><code>-sid <var>num</var></code> : specify the self server ID.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<hr />

<h2 id="clientprog">The Client Programs</h2>

<h3>tcrtest</h3>

<p>The command `<code>tcrtest</code>' is a utility for facility test and performance test.  This command is used in the following format.  `<var>host</var>' specifies the host name of the server.  `<var>rnum</var>' specifies the number of iterations.</p>

<dl class="api">
<dt><code>tcrtest write [-port <var>num</var>] [-cnum <var>num</var>] [-nr] [-rnd] <var>host</var> <var>rnum</var></code></dt>
<dd>Store records with keys of 8 bytes.  They change as `00000001', `00000002'...</dd>
<dt><code>tcrtest read [-port <var>num</var>] [-cnum <var>num</var>] [-mul <var>num</var>] [-rnd] <var>host</var></code></dt>
<dd>Retrieve all records of the database above.</dd>
<dt><code>tcrtest remove [-port <var>num</var>] [-cnum <var>num</var>] [-rnd] <var>host</var></code></dt>
<dd>Remove all records of the database above.</dd>
<dt><code>tcrtest rcat [-port <var>num</var>] [-cnum <var>num</var>] [-rtt <var>num</var>] <var>host</var> <var>rnum</var></code></dt>
<dd>Store records with partway duplicated keys using concatenate mode.</dd>
<dt><code>tcrtest misc [-port <var>num</var>] [-cnum <var>num</var>] <var>host</var> <var>rnum</var></code></dt>
<dd>Perform miscellaneous test of various operations.</dd>
<dt><code>tcrtest wicked [-port <var>num</var>] [-cnum <var>num</var>] <var>host</var> <var>rnum</var></code></dt>
<dd>Perform updating operations of list and map selected at random.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-port <var>num</var></code> : specify the port number.</li>
<li><code>-cnum <var>num</var></code> : specify the number of connections.</li>
<li><code>-nr</code> : use the function `tcrdbputnr' instead of `tcrdbput'.</li>
<li><code>-rnd</code> : select keys at random.</li>
<li><code>-mul <var>num</var></code> : specify the number of records for the mget command.</li>
<li><code>-rtt <var>num</var></code> : use `tcrdbputrtt' and specify the width.</li>
</ul>

<p>If the port number is not more than 0, UNIX domain socket is used and the path of the socket file is specified by the host parameter.  This command returns 0 on success, another on failure.</p>

<h3>tcrmttest</h3>

<p>The command `<code>tcrmttest</code>' is a utility for facility test under multi-thread situation.  This command is used in the following format.  `<var>host</var>' specifies the host name of the server.  `<var>rnum</var>' specifies the number of iterations.</p>


<dl class="api">
<dt><code>tcrmttest write [-port <var>num</var>] [-tnum <var>num</var>] [-nr] [-rnd] <var>host</var> <var>rnum</var></code></dt>
<dd>Store records with keys of 8 bytes.  They change as `00000001', `00000002'...</dd>
<dt><code>tcrmttest read [-port <var>num</var>] [-tnum <var>num</var>] [-mul <var>num</var>] <var>host</var></code></dt>
<dd>Retrieve all records of the database above.</dd>
<dt><code>tcrmttest remove [-port <var>num</var>] [-tnum <var>num</var>] <var>host</var></code></dt>
<dd>Remove all records of the database above.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-port <var>num</var></code> : specify the port number.</li>
<li><code>-tnum <var>num</var></code> : specify the number of running threads.</li>
<li><code>-nr</code> : use the function `tcrdbputnr' instead of `tcrdbput'.</li>
<li><code>-rnd</code> : select keys at random.</li>
<li><code>-mul <var>num</var></code> : specify the number of records for the mget command.</li>
</ul>

<p>If the port number is not more than 0, UNIX domain socket is used and the path of the socket file is specified by the host parameter.  This command returns 0 on success, another on failure.</p>

<h3>tcrmgr</h3>

<p>The command `<code>tcrmgr</code>' is a utility for test and debugging of the remote database API and its applications.  `<var>host</var>' specifies the host name of the server.  `<var>key</var>' specifies the key of a record.  `<var>value</var>' specifies the value of a record.  `<var>dpath</var>' specifies the destination file.  `<var>upath</var>' specifies the update log directory.  `<var>mhost</var>' specifies the host name of the replication master.  `<var>url</var>' specifies the target URL.</p>

<dl class="api">
<dt><code>tcrmgr inform [-port <var>num</var>] [-st] <var>host</var></code></dt>
<dd>Print miscellaneous information to the standard output.</dd>
<dt><code>tcrmgr put [-port <var>num</var>] [-sx] [-dk|-dc] <var>host</var> <var>key</var> <var>value</var></code></dt>
<dd>Store a record.</dd>
<dt><code>tcrmgr out [-port <var>num</var>] [-sx] <var>host</var> <var>key</var></code></dt>
<dd>Remove a record.</dd>
<dt><code>tcrmgr get [-port <var>num</var>] [-sx] [-px] [-pz] <var>host</var> <var>key</var></code></dt>
<dd>Print the value of a record.</dd>
<dt><code>tcrmgr mget [-port <var>num</var>] [-sx] [-px] <var>host</var> [<var>key</var>...]</code></dt>
<dd>Print keys and values of multiple records.</dd>
<dt><code>tcrmgr list [-port <var>num</var>] [-m <var>num</var>] [-pv] [-px] [-fm <var>str</var>] <var>host</var></code></dt>
<dd>Print keys of all records, separated by line feeds.</dd>
<dt><code>tcrmgr sync [-port <var>num</var>] <var>host</var></code></dt>
<dd>Synchronize updated contents with the database file.</dd>
<dt><code>tcrmgr vanish [-port <var>num</var>] <var>host</var></code></dt>
<dd>Remove all records.</dd>
<dt><code>tcrmgr copy [-port <var>num</var>] <var>host</var> <var>dpath</var></code></dt>
<dd>Copy the database file.</dd>
<dt><code>tcrmgr restore [-port <var>num</var>] <var>host</var> <var>upath</var></code></dt>
<dd>Restore the database with update log.</dd>
<dt><code>tcrmgr setmst [-port <var>num</var>] [-mport <var>num</var>] <var>host</var> [<var>mhost</var>]</code></dt>
<dd>Set the replication master.</dd>
<dt><code>tcrmgr repl [-port <var>num</var>] [-ts <var>num</var>] [-sid <var>num</var>] [-ph] <var>host</var></code></dt>
<dd>Replicate the update log.</dd>
<dt><code>tcrmgr http [-ah <var>name</var> <var>value</var>] [-ih] <var>url</var></code></dt>
<dd>Fetch the resource of a URL by HTTP.</dd>
<dt><code>tcrmgr version</code></dt>
<dd>Print the version information of Tokyo Tyrant.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-port <var>num</var></code> : specify the port number.</li>
<li><code>-st</code> : print miscellaneous status data.</li>
<li><code>-sx</code> : input data is evaluated as a hexadecimal data string.</li>
<li><code>-dk</code> : use the function `tchdbputkeep' instead of `tchdbput'.</li>
<li><code>-dc</code> : use the function `tchdbputcat' instead of `tchdbput'.</li>
<li><code>-px</code> : output data is converted into a hexadecimal data string.</li>
<li><code>-pz</code> : do not append line feed at the end of the output.</li>
<li><code>-m <var>num</var></code> : specify the maximum number of the output.</li>
<li><code>-pv</code> : print values of records also.</li>
<li><code>-fm <var>str</var></code> : specify the prefix of keys.</li>
<li><code>-mport <var>num</var></code> : specify the port number of the replication master.</li>
<li><code>-ts <var>num</var></code> : specify the beginning time stamp.</li>
<li><code>-sid <var>num</var></code> : specify the self server ID.</li>
<li><code>-ph</code> : print human-readable data.</li>
<li><code>-ah <var>name</var> <var>value</var></code> : add a request header.</li>
<li><code>-ih</code> : output response headers also.</li>
</ul>

<p>If the port number is not more than 0, UNIX domain socket is used and the path of the socket file is specified by the host parameter.  This command returns 0 on success, another on failure.</p>

<hr />

<h2 id="tcrdbapi">The Remote Database API</h2>

<p>Remote database is a set of interfaces to use an abstract database of Tokyo Cabinet, mediated by a server of Tokyo Tyrant.  See `<code>tcrdb.h</code>' for entire specification.</p>

<h3>Description</h3>

<p>To use the remote database API, include `<code>tcrdb.h</code>' and related standard header files.  Usually, write the following description near the front of a source file.</p>

<dl>
<dt><code>#include &lt;tcrdb.h&gt;</code></dt>
<dt><code>#include &lt;stdlib.h&gt;</code></dt>
<dt><code>#include &lt;stdbool.h&gt;</code></dt>
<dt><code>#include &lt;stdint.h&gt;</code></dt>
</dl>

<p>Objects whose type is pointer to `<code>TCRDB</code>' are used to handle remote databases.  A remote database object is created with the function `<code>tcrdbnew</code>' and is deleted with the function `<code>tcrdbdel</code>'.  To avoid memory leak, it is important to delete every object when it is no longer in use.</p>

<p>Before operations to store or retrieve records, it is necessary to connect the remote database object to the server.  The function `<code>tcrdbopen</code>' is used to open a database connection and the function `<code>tcrdbclose</code>' is used to close the connection.</p>

<h3>API</h3>

<p>The function `tcrdberrmsg' is used in order to get the message string corresponding to an error code.</p>

<dl class="api">
<dt><code>const char *tcrdberrmsg(int <var>ecode</var>);</code></dt>
<dd>`<var>ecode</var>' specifies the error code.</dd>
<dd>The return value is the message string of the error code.</dd>
</dl>

<p>The function `tcrdbnew' is used in order to create a remote database object.</p>

<dl class="api">
<dt><code>TCRDB *tcrdbnew(void);</code></dt>
<dd>The return value is the new remote database object.</dd>
</dl>

<p>The function `tcrdbdel' is used in order to delete a remote database object.</p>

<dl class="api">
<dt><code>void tcrdbdel(TCRDB *<var>rdb</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
</dl>

<p>The function `tcrdbecode' is used in order to get the last happened error code of a remote database object.</p>

<dl class="api">
<dt><code>int tcrdbecode(TCRDB *<var>rdb</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>The return value is the last happened error code.</dd>
<dd>The following error code is defined: `TTESUCCESS' for success, `TTEINVALID' for invalid operation, `TTENOHOST' for host not found, `TTEREFUSED' for connection refused, `TTESEND' for send error, `TTERECV' for recv error, `TTEKEEP' for existing record, `TTENOREC' for no record found, `TTEMISC' for miscellaneous error.</dd>
</dl>

<p>The function `tcrdbopen' is used in order to open a remote database.</p>

<dl class="api">
<dt><code>bool tcrdbopen(TCRDB *<var>rdb</var>, const char *<var>host</var>, int <var>port</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>`<var>host</var>' specifies the name or the address of the server.</dd>
<dd>`<var>port</var>' specifies the port number.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcrdbclose' is used in order to close a remote database object.</p>

<dl class="api">
<dt><code>bool tcrdbclose(TCRDB *<var>rdb</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcrdbput' is used in order to store a record into a remote database object.</p>

<dl class="api">
<dt><code>bool tcrdbput(TCRDB *<var>rdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcrdbput2' is used in order to store a string record into a remote object.</p>

<dl class="api">
<dt><code>bool tcrdbput2(TCRDB *<var>rdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcrdbputkeep' is used in order to store a new record into a remote database object.</p>

<dl class="api">
<dt><code>bool tcrdbputkeep(TCRDB *<var>rdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcrdbputkeep2' is used in order to store a new string record into a remote database object.</p>

<dl class="api">
<dt><code>bool tcrdbputkeep2(TCRDB *<var>rdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcrdbputcat' is used in order to concatenate a value at the end of the existing record in a remote database object.</p>

<dl class="api">
<dt><code>bool tcrdbputcat(TCRDB *<var>rdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcrdbputcat2' is used in order to concatenate a string value at the end of the existing record in a remote database object.</p>

<dl class="api">
<dt><code>bool tcrdbputcat2(TCRDB *<var>rdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcrdbputrtt' is used in order to concatenate a value at the end of the existing record and rotate it to the left.</p>

<dl class="api">
<dt><code>bool tcrdbputrtt(TCRDB *<var>rdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>, int <var>width</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>`<var>width</var>' specifies the width of the record.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcrdbputrtt2' is used in order to concatenate a string value at the end of the existing record and rotate it to the left.</p>

<dl class="api">
<dt><code>bool tcrdbputrtt2(TCRDB *<var>rdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>, int <var>width</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>`<var>width</var>' specifies the width of the record.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcrdbputnr' is used in order to store a record into a remote database object without response from the server.</p>

<dl class="api">
<dt><code>bool tcrdbputnr(TCRDB *<var>rdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcrdbputnr2' is used in order to store a string record into a remote object without response from the server.</p>

<dl class="api">
<dt><code>bool tcrdbputnr2(TCRDB *<var>rdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcrdbout' is used in order to remove a record of a remote database object.</p>

<dl class="api">
<dt><code>bool tcrdbout(TCRDB *<var>rdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcrdbout2' is used in order to remove a string record of a remote database object.</p>

<dl class="api">
<dt><code>bool tcrdbout2(TCRDB *<var>rdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcrdbget' is used in order to retrieve a record in a remote database object.</p>

<dl class="api">
<dt><code>void *tcrdbget(TCRDB *<var>rdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcrdbget2' is used in order to retrieve a string record in a remote database object.</p>

<dl class="api">
<dt><code>char *tcrdbget2(TCRDB *<var>rdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcrdbget3' is used in order to retrieve records in a remote database object.</p>

<dl class="api">
<dt><code>bool tcrdbget3(TCRDB *<var>rdb</var>, TCMAP *<var>recs</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>`<var>recs</var>' specifies a map object containing the retrieval keys.  As a result of this function, keys existing in the database have the corresponding values and keys not existing in the database are removed.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcrdbvsiz' is used in order to get the size of the value of a record in a remote database object.</p>

<dl class="api">
<dt><code>int tcrdbvsiz(TCRDB *<var>rdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tcrdbvsiz2' is used in order to get the size of the value of a string record in a remote database object.</p>

<dl class="api">
<dt><code>int tcrdbvsiz2(TCRDB *<var>rdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tcrdbiterinit' is used in order to initialize the iterator of a remote database object.</p>

<dl class="api">
<dt><code>bool tcrdbiterinit(TCRDB *<var>rdb</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The iterator is used in order to access the key of every record stored in a database.</dd>
</dl>

<p>The function `tcrdbiternext' is used in order to get the next key of the iterator of a remote database object.</p>

<dl class="api">
<dt><code>void *tcrdbiternext(TCRDB *<var>rdb</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  The iterator can be updated by multiple connections and then it is not assured that every record is traversed.</dd>
</dl>

<p>The function `tcrdbiternext2' is used in order to get the next key string of the iterator of a remote database object.</p>

<dl class="api">
<dt><code>char *tcrdbiternext2(TCRDB *<var>rdb</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>If successful, the return value is the string of the next key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  The iterator can be updated by multiple connections and then it is not assured that every record is traversed.</dd>
</dl>

<p>The function `tcrdbfwmkeys' is used in order to get forward matching keys in a remote database object.</p>

<dl class="api">
<dt><code>TCLIST *tcrdbfwmkeys(TCRDB *<var>rdb</var>, const void *<var>pbuf</var>, int <var>psiz</var>, int <var>max</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>`<var>pbuf</var>' specifies the pointer to the region of the prefix.</dd>
<dd>`<var>psiz</var>' specifies the size of the region of the prefix.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding keys.  This function does never fail and return an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcrdbfwmkeys2' is used in order to get forward matching string keys in a remote database object.</p>

<dl class="api">
<dt><code>TCLIST *tcrdbfwmkeys2(TCRDB *<var>rdb</var>, const char *<var>pstr</var>, int <var>max</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>`<var>pstr</var>' specifies the string of the prefix.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding keys.  This function does never fail and return an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcrdbaddint' is used in order to add an integer to a record in a remote database object.</p>

<dl class="api">
<dt><code>int tcrdbaddint(TCRDB *<var>rdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int <var>num</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>If successful, the return value is the summation value, else, it is `INT_MIN'.</dd>
<dd>If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tcrdbadddouble' is used in order to add a real number to a record in a remote database object.</p>

<dl class="api">
<dt><code>double tcrdbadddouble(TCRDB *<var>rdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, double <var>num</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>If successful, the return value is the summation value, else, it is `NAN'.</dd>
<dd>If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tcrdbsync' is used in order to synchronize updated contents of a remote database object with the file and the device.</p>

<dl class="api">
<dt><code>bool tcrdbsync(TCRDB *<var>rdb</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>This function fails and has no effect for on-memory database.</dd>
</dl>

<p>The function `tcrdbvanish' is used in order to remove all records of a remote database object.</p>

<dl class="api">
<dt><code>bool tcrdbvanish(TCRDB *<var>rdb</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcrdbcopy' is used in order to copy the database file of a remote database object.</p>

<dl class="api">
<dt><code>bool tcrdbcopy(TCRDB *<var>rdb</var>, const char *<var>path</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>`<var>path</var>' specifies the path of the destination file.  If it begins with `@', the trailing substring is executed as a command line.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if the executed command returns non-zero code.</dd>
<dd>The database file is assured to be kept synchronized and not modified while the copying or executing operation is in progress.  So, this function is useful to create a backup file of the database file.  This function fails and has no effect for on-memory database.</dd>
</dl>

<p>The function `tcrdbrestore' is used in order to restore the database file of a remote database object from the update log.</p>

<dl class="api">
<dt><code>bool tcrdbrestore(TCRDB *<var>rdb</var>, const char *<var>path</var>, uint64_t <var>ts</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>`<var>path</var>' specifies the path of the update log directory.  If it begins with `+', the trailing substring is treated as the path and consistency checking is omitted.</dd>
<dd>`<var>ts</var>' specifies the beginning time stamp in microseconds.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcrdbsetmst' is used in order to set the replication master of a remote database object from the update log.</p>

<dl class="api">
<dt><code>bool tcrdbsetmst(TCRDB *<var>rdb</var>, const char *<var>host</var>, int <var>port</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>`<var>host</var>' specifies the name or the address of the server.  If it is `NULL', replication of the database is disabled.</dd>
<dd>`<var>port</var>' specifies the port number.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcrdbrnum' is used in order to get the number of records of a remote database object.</p>

<dl class="api">
<dt><code>uint64_t tcrdbrnum(TCRDB *<var>rdb</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>The return value is the number of records or 0 if the object does not connect to any database server.</dd>
</dl>

<p>The function `tcrdbsize' is used in order to get the size of the database of a remote database object.</p>

<dl class="api">
<dt><code>uint64_t tcrdbsize(TCRDB *<var>rdb</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>The return value is the size of the database or 0 if the object does not connect to any database server.</dd>
</dl>

<p>The function `tcrdbstat' is used in order to get the status string of the database of a remote database object.</p>

<dl class="api">
<dt><code>char *tcrdbstat(TCRDB *<var>rdb</var>);</code></dt>
<dd>`<var>rdb</var>' specifies the remote database object.</dd>
<dd>The return value is the status message of the database or `NULL' if the object does not connect to any database server.  The message format is TSV.  The first field of each line means the parameter name and the second field means the value.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<h3>Example Code</h3>

<p>The following code is an example to use a remote database.</p>

<pre>#include &lt;tcrdb.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;

int main(int argc, char **argv){

  TCRDB *rdb;
  int ecode;
  char *value;

  /* create the object */
  rdb = tcrdbnew();

  /* open the database */
  if(!tcrdbopen(rdb, "localhost", 1978)){
    ecode = tcrdbecode(rdb);
    fprintf(stderr, "open error: %s\n", tcrdberrmsg(ecode));
  }

  /* store records */
  if(!tcrdbput2(rdb, "foo", "hop") ||
     !tcrdbput2(rdb, "bar", "step") ||
     !tcrdbput2(rdb, "baz", "jump")){
    ecode = tcrdbecode(rdb);
    fprintf(stderr, "put error: %s\n", tcrdberrmsg(ecode));
  }

  /* retrieve records */
  value = tcrdbget2(rdb, "foo");
  if(value){
    printf("%s\n", value);
    free(value);
  } else {
    ecode = tcrdbecode(rdb);
    fprintf(stderr, "get error: %s\n", tcrdberrmsg(ecode));
  }

  /* close the database */
  if(!tcrdbclose(rdb)){
    ecode = tcrdbecode(rdb);
    fprintf(stderr, "close error: %s\n", tcrdberrmsg(ecode));
  }

  /* delete the object */
  tcrdbdel(rdb);

  return 0;
}
</pre>

<h3>How to Use the Library</h3>

<p>The API of C is available by programs conforming to the C89 (ANSI C) standard or the C99 standard.  As the header files of Tokyo Tyrant are provided as `<code>tcrdb.h</code>', applications should include it to use the API.  As the library is provided as `<code>libtokyotyrant.a</code>' and `<code>libtokyotyrant.so</code>' and they depends `<code>libtokyocabinet.so</code>', `<code>libz.so</code>', `<code>libresolv.so</code>', `<code>libnsl.so</code>', `<code>libpthread.so</code>', `<code>libm.so</code>', and `<code>libc.so</code>', linker options `<code>-ltokyotyrant</code>', `<code>-ltokyocabinet</code>', `<code>-lz</code>', `<code>-lresolv</code>', `<code>-lnsl</code>', `<code>-lpthread</code>', `<code>-lm</code>', and `<code>-lc</code>' are required for build command.  A typical build command is the following.</p>

<pre>gcc -I/usr/local/include tc_example.c -o tc_example \
  -L/usr/local/lib -ltokyotyrant -ltokyocabinet -lz -lresolv -lnsl -lpthread -lm -lc
</pre>

<p>You can also use Tokyo Tyrant in programs written in C++.  Because each header is wrapped in C linkage (`<code>extern "C"</code>' block), you can simply include them into your C++ programs.</p>

<hr />

<h2 id="protocol">Protocol</h2>

<p>The protocol between the server and clients stands on TCP/IP.  By default, the service port is bound to every address of the local host and the port number is 1978.  Each session of the server and a client is composed of a request and a response.  Requests are classified into the following commands.  Structure of request and response is determined by the command.  The byte order of integer in request and response is big endian.</p>

<dl class="api">
<dt><code>put</code>: for the function `tcrdbput'</dt>
<dd><dl>
<dt>Request: <code>[magic:2][ksiz:4][vsiz:4][kbuf:*][vbuf:*]</code></dt>
<dd>Two bytes of the command ID: 0xC8 and 0x10</dd>
<dd>A 32-bit integer standing for the length of the key</dd>
<dd>A 32-bit integer standing for the length of the value</dd>
<dd>Arbitrary data of the key</dd>
<dd>Arbitrary data of the value</dd>
<dt>Response: <code>[code:1]</code></dt>
<dd>An 8-bit integer whose value is 0 on success or another on failure</dd>
</dl></dd>
</dl>

<dl class="api">
<dt><code>putkeep</code>: for the function `tcrdbputkeep'</dt>
<dd><dl>
<dt>Request: <code>[magic:2][ksiz:4][vsiz:4][kbuf:*][vbuf:*]</code></dt>
<dd>Two bytes of the command ID: 0xC8 and 0x11</dd>
<dd>A 32-bit integer standing for the length of the key</dd>
<dd>A 32-bit integer standing for the length of the value</dd>
<dd>Arbitrary data of the key</dd>
<dd>Arbitrary data of the value</dd>
<dt>Response: <code>[code:1]</code></dt>
<dd>An 8-bit integer whose value is 0 on success or another on failure</dd>
</dl></dd>
</dl>

<dl class="api">
<dt><code>putcat</code>: for the function `tcrdbputcat'</dt>
<dd><dl>
<dt>Request: <code>[magic:2][ksiz:4][vsiz:4][kbuf:*][vbuf:*]</code></dt>
<dd>Two bytes of the command ID: 0xC8 and 0x12</dd>
<dd>A 32-bit integer standing for the length of the key</dd>
<dd>A 32-bit integer standing for the length of the value</dd>
<dd>Arbitrary data of the key</dd>
<dd>Arbitrary data of the value</dd>
<dt>Response: <code>[code:1]</code></dt>
<dd>An 8-bit integer whose value is 0 on success or another on failure</dd>
</dl></dd>
</dl>

<dl class="api">
<dt><code>putrtt</code>: for the function `tcrdbputrtt'</dt>
<dd><dl>
<dt>Request: <code>[magic:2][ksiz:4][vsiz:4][width:4][kbuf:*][vbuf:*]</code></dt>
<dd>Two bytes of the command ID: 0xC8 and 0x13</dd>
<dd>A 32-bit integer standing for the length of the key</dd>
<dd>A 32-bit integer standing for the length of the value</dd>
<dd>A 32-bit integer standing for the width</dd>
<dd>Arbitrary data of the key</dd>
<dd>Arbitrary data of the value</dd>
<dt>Response: <code>[code:1]</code></dt>
<dd>An 8-bit integer whose value is 0 on success or another on failure</dd>
</dl></dd>
</dl>

<dl class="api">
<dt><code>putnr</code>: for the function `tcrdbputnr'</dt>
<dd><dl>
<dt>Request: <code>[magic:2][ksiz:4][vsiz:4][kbuf:*][vbuf:*]</code></dt>
<dd>Two bytes of the command ID: 0xC8 and 0x18</dd>
<dd>A 32-bit integer standing for the length of the key</dd>
<dd>A 32-bit integer standing for the length of the value</dd>
<dd>Arbitrary data of the key</dd>
<dd>Arbitrary data of the value</dd>
<dt>Response: (none)</dt>
</dl></dd>
</dl>

<dl class="api">
<dt><code>out</code>: for the function `tcrdbout'</dt>
<dd><dl>
<dt>Request: <code>[magic:2][ksiz:4][kbuf:*]</code></dt>
<dd>Two bytes of the command ID: 0xC8 and 0x20</dd>
<dd>A 32-bit integer standing for the length of the key</dd>
<dd>Arbitrary data of the key</dd>
<dt>Response: <code>[code:1]</code></dt>
<dd>An 8-bit integer whose value is 0 on success or another on failure</dd>
</dl></dd>
</dl>

<dl class="api">
<dt><code>get</code>: for the function `tcrdbget'</dt>
<dd><dl>
<dt>Request: <code>[magic:2][ksiz:4][kbuf:*]</code></dt>
<dd>Two bytes of the command ID: 0xC8 and 0x30</dd>
<dd>A 32-bit integer standing for the length of the key</dd>
<dd>Arbitrary data of the key</dd>
<dt>Response: <code>[code:1]([vsiz:4][vbuf:*])</code></dt>
<dd>An 8-bit integer whose value is 0 on success or another on failure</dd>
<dd>on success: A 32-bit integer standing for the length of the value</dd>
<dd>on success: Arbitrary data of the value</dd>
</dl></dd>
</dl>

<dl class="api">
<dt><code>mget</code>: for the function `tcrdbget3'</dt>
<dd><dl>
<dt>Request: <code>[magic:2][rnum:4][{[ksiz:4][kbuf:*]}:*]</code></dt>
<dd>Two bytes of the command ID: 0xC8 and 0x31</dd>
<dd>A 32-bit integer standing for the number of keys</dd>
<dd>iteration: A 32-bit integer standing for the length of the key</dd>
<dd>iteration: Arbitrary data of the key</dd>
<dt>Response: <code>[code:1][rnum:4][{[ksiz:4][vsiz:4][kbuf:*][vbuf:*]}:*]</code></dt>
<dd>An 8-bit integer whose value is 0 on success or another on failure</dd>
<dd>A 32-bit integer standing for the number of records</dd>
<dd>iteration: A 32-bit integer standing for the length of the key</dd>
<dd>iteration: A 32-bit integer standing for the length of the value</dd>
<dd>iteration: Arbitrary data of the key</dd>
<dd>iteration: Arbitrary data of the value</dd>
</dl></dd>
</dl>

<dl class="api">
<dt><code>vsiz</code>: for the function `tcrdbvsiz'</dt>
<dd><dl>
<dt>Request: <code>[magic:2][ksiz:4][kbuf:*]</code></dt>
<dd>Two bytes of the command ID: 0xC8 and 0x38</dd>
<dd>A 32-bit integer standing for the length of the key</dd>
<dd>Arbitrary data of the key</dd>
<dt>Response: <code>[code:1]([vsiz:4])</code></dt>
<dd>An 8-bit integer whose value is 0 on success or another on failure</dd>
<dd>on success: A 32-bit integer standing for the length of the value</dd>
</dl></dd>
</dl>

<dl class="api">
<dt><code>iterinit</code>: for the function `tcrdbiterinit'</dt>
<dd><dl>
<dt>Request: <code>[magic:2]</code></dt>
<dd>Two bytes of the command ID: 0xC8 and 0x50</dd>
<dt>Response: <code>[code:1]</code></dt>
<dd>An 8-bit integer whose value is 0 on success or another on failure</dd>
</dl></dd>
</dl>

<dl class="api">
<dt><code>iternext</code>: for the function `tcrdbiternext'</dt>
<dd><dl>
<dt>Request: <code>[magic:2]</code></dt>
<dd>Two bytes of the command ID: 0xC8 and 0x51</dd>
<dt>Response: <code>[code:1]([ksiz:4][kbuf:*])</code></dt>
<dd>An 8-bit integer whose value is 0 on success or another on failure</dd>
<dd>on success: A 32-bit integer standing for the length of the key</dd>
<dd>on success: Arbitrary data of the key</dd>
</dl></dd>
</dl>

<dl class="api">
<dt><code>fwmkeys</code>: for the function `tcrdbfwmkeys'</dt>
<dd><dl>
<dt>Request: <code>[magic:2][psiz:4][max:4][pbuf:*]</code></dt>
<dd>Two bytes of the command ID: 0xC8 and 0x58</dd>
<dd>A 32-bit integer standing for the length of the prefix</dd>
<dd>A 32-bit integer standing for the maximum number of keys to be fetched.</dd>
<dd>Arbitrary data of the prefix</dd>
<dt>Response: <code>[code:1][knum:4][{[ksiz:4][kbuf:*]}:*]</code></dt>
<dd>An 8-bit integer whose value is 0 on success or another on failure</dd>
<dd>A 32-bit integer standing for the number of keys</dd>
<dd>iteration: A 32-bit integer standing for the length of the key</dd>
<dd>iteration: Arbitrary data of the key</dd>
</dl></dd>
</dl>

<dl class="api">
<dt><code>addint</code>: for the function `tcrdbaddint'</dt>
<dd><dl>
<dt>Request: <code>[magic:2][ksiz:4][num:4][kbuf:*]</code></dt>
<dd>Two bytes of the command ID: 0xC8 and 0x60</dd>
<dd>A 32-bit integer standing for the length of the key</dd>
<dd>A 32-bit integer standing for the additional number</dd>
<dd>Arbitrary data of the key</dd>
<dt>Response: <code>[code:1]([sum:4])</code></dt>
<dd>An 8-bit integer whose value is 0 on success or another on failure</dd>
<dd>on success: A 32-bit integer standing for the summation value</dd>
</dl></dd>
</dl>

<dl class="api">
<dt><code>adddouble</code>: for the function `tcrdbadddouble'</dt>
<dd><dl>
<dt>Request: <code>[magic:2][ksiz:4][integ:8][fract:8][kbuf:*]</code></dt>
<dd>Two bytes of the command ID: 0xC8 and 0x61</dd>
<dd>A 32-bit integer standing for the length of the key</dd>
<dd>A 64-bit integer standing for the integral of the additional number.</dd>
<dd>A 64-bit integer standing for the trillionfold fractuation of the additional number.</dd>
<dd>Arbitrary data of the key</dd>
<dt>Response: <code>[code:1]([integ:8][fract:8])</code></dt>
<dd>An 8-bit integer whose value is 0 on success or another on failure</dd>
<dd>on success: A 64-bit integer standing for the integral of the summation value.</dd>
<dd>on success: A 64-bit integer standing for the trillionfold fractuation of the summation value.</dd>
</dl></dd>
</dl>

<dl class="api">
<dt><code>sync</code>: for the function `tcrdbsync'</dt>
<dd><dl>
<dt>Request: <code>[magic:2]</code></dt>
<dd>Two bytes of the command ID: 0xC8 and 0x70</dd>
<dt>Response: <code>[code:1]</code></dt>
<dd>An 8-bit integer whose value is 0 on success or another on failure</dd>
</dl></dd>
</dl>

<dl class="api">
<dt><code>vanish</code>: for the function `tcrdbvanish'</dt>
<dd><dl>
<dt>Request: <code>[magic:2]</code></dt>
<dd>Two bytes of the command ID: 0xC8 and 0x71</dd>
<dt>Response: <code>[code:1]</code></dt>
<dd>An 8-bit integer whose value is 0 on success or another on failure</dd>
</dl></dd>
</dl>

<dl class="api">
<dt><code>copy</code>: for the function `tcrdbcopy'</dt>
<dd><dl>
<dt>Request: <code>[magic:2][psiz:4][path:*]</code></dt>
<dd>Two bytes of the command ID: 0xC8 and 0x72</dd>
<dd>A 32-bit integer standing for the length of the path</dd>
<dd>Arbitrary data of the path</dd>
<dt>Response: <code>[code:1]</code></dt>
<dd>An 8-bit integer whose value is 0 on success or another on failure</dd>
</dl></dd>
</dl>

<dl class="api">
<dt><code>restore</code>: for the function `tcrdbrestore'</dt>
<dd><dl>
<dt>Request: <code>[magic:2][psiz:4][path:*]</code></dt>
<dd>Two bytes of the command ID: 0xC8 and 0x73</dd>
<dd>A 32-bit integer standing for the length of the path</dd>
<dd>Arbitrary data of the path</dd>
<dt>Response: <code>[code:1]</code></dt>
<dd>An 8-bit integer whose value is 0 on success or another on failure</dd>
</dl></dd>
</dl>

<dl class="api">
<dt><code>setmst</code>: for the function `tcrdbsetmst'</dt>
<dd><dl>
<dt>Request: <code>[magic:2][hsiz:4][port:4][host:*]</code></dt>
<dd>Two bytes of the command ID: 0xC8 and 0x78</dd>
<dd>A 32-bit integer standing for the length of the host name</dd>
<dd>A 32-bit integer standing for the port number</dd>
<dd>Arbitrary data of the host name</dd>
<dt>Response: <code>[code:1]</code></dt>
<dd>An 8-bit integer whose value is 0 on success or another on failure</dd>
</dl></dd>
</dl>

<dl class="api">
<dt><code>rnum</code>: for the function `tcrdbrnum'</dt>
<dd><dl>
<dt>Request: <code>[magic:2]</code></dt>
<dd>Two bytes of the command ID: 0xC8 and 0x80</dd>
<dt>Response: <code>[code:1][rnum:8]</code></dt>
<dd>An 8-bit integer whose value is always 0</dd>
<dd>A 64-bit integer standing for the number of records</dd>
</dl></dd>
</dl>

<dl class="api">
<dt><code>size</code>: for the function `tcrdbsize'</dt>
<dd><dl>
<dt>Request: <code>[magic:2]</code></dt>
<dd>Two bytes of the command ID: 0xC8 and 0x81</dd>
<dt>Response: <code>[code:1][rnum:8]</code></dt>
<dd>An 8-bit integer whose value is always 0</dd>
<dd>A 64-bit integer standing for the size of the database</dd>
</dl></dd>
</dl>

<dl class="api">
<dt><code>stat</code>: for the function `tcrdbstat'</dt>
<dd><dl>
<dt>Request: <code>[magic:2]</code></dt>
<dd>Two bytes of the command ID: 0xC8 and 0x88</dd>
<dt>Response: <code>[code:1][ssiz:4][sbuf:*]</code></dt>
<dd>An 8-bit integer whose value is always 0</dd>
<dd>A 32-bit integer standing for the length of the status message</dd>
</dl></dd>
</dl>

<p>To finish the session, the client can shutdown and close the socket at any time.  If not closed, the connection can be reused for the next session.  If protocol violation or some fatal error occurs the server immediately breaks the session and closes the connection.</p>

<p>As for the memcached compatible protocol, the server implements the following commands; "set", "add", "replace", "get", "delete", "incr", "decr", "stats", "flush_all", "version", and "quit".  "noreply" options of update commands are also supported.  However, "flags", "exptime", and "cas unique" parameters are ignored.  The limitation size of each query is 8192 bytes except for the entity of the value.</p>

<p>As for the HTTP/1.1 compatible protocol, the server implements the following commands; "GET" (relevant to `tcrdbget'), "HEAD" (relevant to `tcrdbvsiz'), "PUT" (relevant to `tcrdbput'), "POST" (relevant to `tcrdbputkeep'), and "DELETE" (relevant to `tcrdbout').  The URI of each request is treated as the key encoded by the URL encoding.  And the entity body is treated as the value.  However, headers except for "Connection" and "Content-Length" are ignored.  The limitation size of each query is 8192 bytes.</p>

<hr />

<h2 id="tutorial">Tutorial</h2>

<h3>Basic Use</h3>

<p>After installation of Tokyo Tyrant, you can start the server immediately by executing the command `<code>ttserver</code>' in the terminal.  By default, the server listens to the port 1978 and serves as the accessor of an on-memory database, which is useful to store cache data.</p>

<pre>[terminal-1]$ ttserver
</pre>

<p>To test storing operations, execute the following commands in another terminal.  `<code>tcrmgr put</code>' calls the function `<code>tcrdbput</code>'.</p>

<pre>[terminal-2]$ tcrmgr put localhost one first
[terminal-2]$ tcrmgr put localhost two second
[terminal-2]$ tcrmgr put localhost three third
</pre>

<p>To test retrieving operations, execute the following commands in another terminal.  `<code>tcrmgr get</code>' calls the function `<code>tcrdbget</code>'.</p>

<pre>[terminal-2]$ tcrmgr get localhost one
[terminal-2]$ tcrmgr get localhost two
[terminal-2]$ tcrmgr get localhost three
</pre>

<p>To retrieve multiple records at once, execute the following command.  `<code>tcrmgr mget</code>' calls the function `<code>tcrdbget3</code>'.</p>

<pre>[terminal-2]$ tcrmgr mget localhost one two three
</pre>

<p>To terminate the server, input Ctrl-C in the terminal of the server.</p>

<p>Next, let's run the server that handles a hash database, by specifying the file name whose suffix is `<code>.tch</code>'.</p>

<pre>[terminal-1]$ ttserver casket.tch
</pre>

<p>Store some records.</p>

<pre>[terminal-2]$ tcrmgr put localhost one first
[terminal-2]$ tcrmgr put localhost two second
[terminal-2]$ tcrmgr put localhost three third
</pre>

<p>Terminate the server by Ctrl-C, and then restart the server.</p>

<pre>[terminal-1]$ ttserver casket.tch
</pre>

<p>Check consistency of stored records.</p>

<pre>[terminal-2]$ tcrmgr mget localhost one two three
</pre>

<p>Terminate the server by Ctrl-C and remove the database, for the successive tutorial.</p>

<pre>[terminal-1]$ rm casket.tch
</pre>

<h3>Daemon</h3>

<p>To run the server as a daemon process, specify the option `<code>-dmn</code>'.  Moreover, the option `<code>-pid</code>' should be specified to record the process ID into a file.  Note that the current directory of the daemon process is changed to the root directory.  So, the file path parameter should be expressed as absolute path.</p>

<pre>[terminal-1]$ ttserver -dmn -pid /tmp/ttserver.pid /tmp/casket.tch
</pre>

<p>To terminate the daemonized server, check the process ID from the file specified by `<code>-pid</code>' and send the SIGTERM signal to the process.</p>

<pre>[terminal-1]$ kill -TERM `cat /tmp/ttserver.pid`
</pre>

<p>To run the server by the RC script of the operating system, use `<code>ttservctl</code>'.  As for most Linux distribution, append the following line to `<code>/etc/rc.local</code>'.</p>

<pre>/usr/local/sbin/ttservctl start
</pre>

<p>By default, the database file and the related files are placed under `<code>/var/ttserver</code>'.  Because `<code>ttservctl</code>' is a tiny shell script, copy and edit it for your purpose.  Also, it is suitable to install the modified script into `<code>/etc/init.d</code>' and set symbolic links from `<code>/etc/rc3.d/S98ttserver</code>' and `<code>/etc/rc5.d/S98ttserver</code>'.</p>

<h3>Backup and Recovery</h3>

<p>Let's run the server again to continue this tutorial.</p>

<pre>[terminal-1]$ ttserver casket.tch
</pre>

<p>Store some records.</p>

<pre>[terminal-2]$ tcrmgr put localhost one first
[terminal-2]$ tcrmgr put localhost two second
[terminal-2]$ tcrmgr put localhost three third
</pre>

<p>To back up the database file, indicate the destination path to the server by the command `<code>tcrmgr copy</code>'.  Note that the backup file is created on the local file system of the server (not on the client side).</p>

<pre>[terminal-2]$ tcrmgr copy localhost backup.tch
</pre>

<p>Terminate the server by Ctrl-C and remove the database.</p>

<pre>[terminal-1]$ rm casket.tch
</pre>

<p>Recover the database from the backup file and restart the server.</p>

<pre>[terminal-1]$ cp backup.tch casket.tch
[terminal-1]$ ttserver casket.tch
</pre>

<p>Check consistency of stored records.</p>

<pre>[terminal-2]$ tcrmgr mget localhost one two three
</pre>

<p>Terminate the server by Ctrl-C and remove the databases, for the successive tutorial.</p>

<pre>[terminal-1]$ rm casket.tch backup.tch
</pre>

<h3>Update Log</h3>

<p>Let's run the server with update logging enabled.  The option `<code>-ulog</code>' specifies the directory to contain the update log files.</p>

<pre>[terminal-1]$ mkdir ulog
[terminal-1]$ ttserver -ulog ulog casket.tch
</pre>

<p>Store some records.</p>

<pre>[terminal-2]$ tcrmgr put localhost one first
[terminal-2]$ tcrmgr put localhost two second
[terminal-2]$ tcrmgr put localhost three third
</pre>

<p>Terminate the server by Ctrl-C and remove the database.</p>

<pre>[terminal-1]$ rm casket.tch
</pre>

<p>Escape the update log directoty and restart the server.</p>

<pre>[terminal-1]$ mv ulog ulog-back
[terminal-1]$ mkdir ulog
[terminal-1]$ ttserver -ulog ulog casket.tch
</pre>

<p>Restore the database from the escaped update log, by the command `<code>tcrmgr restore</code>' on the client side.</p>

<pre>[terminal-2]$ tcrmgr restore localhost ulog-back
</pre>

<p>Check consistency of stored records.</p>

<pre>[terminal-2]$ tcrmgr mget localhost one two three
</pre>

<p>Terminate the server by Ctrl-C and remove the database, for the successive tutorial.</p>

<pre>[terminal-1]$ rm -rf casket.tch ulog ulog-back
</pre>

<h3>Replication</h3>

<p>Replication is a mechanism to synchronize two or more database servers for high availability and high integrity.  The replication source server is called "master" and each destination server is called "slave".  Replication requires the following preconditions.</p>

<ul>
<li>The master must record the update log.</li>
<li>The master must specify the unique server ID.</li>
<li>Each slave must record the update log because it may become the master when fail over.</li>
<li>Each slave must specify the unique server ID because it may become the master when fail over.</li>
<li>Each slave must specify the address and the port number of the master server.</li>
<li>Each slave must specify the replication time stamp file.</li>
</ul>

<p>This section describes how to set up one master (at port 1978) and one slave (at port 1979) replication.  First, let's run the master server.</p>

<pre>[terminal-1]$ mkdir ulog-1
[terminal-1]$ ttserver -port 1978 -ulog ulog-1 -sid 1 casket-1.tch
</pre>

<p>Next, let's run the slave server in another terminal.</p>

<pre>[terminal-2]$ mkdir ulog-2
[terminal-2]$ ttserver -port 1979 -ulog ulog-2 -sid 2 \
                -mhost localhost -mport 1978 -rts 2.rts casket-2.tch
</pre>

<p>Store some records into the master.</p>

<pre>[terminal-3]$ tcrmgr put -port 1978 localhost one first
[terminal-3]$ tcrmgr put -port 1978 localhost two second
[terminal-3]$ tcrmgr put -port 1978 localhost three third
</pre>

<p>Check consistency of stored records in the master and the slave.</p>

<pre>[terminal-2]$ tcrmgr mget -port 1978 localhost one two three
[terminal-2]$ tcrmgr mget -port 1979 localhost one two three
</pre>

<p>Let's simulate the case that the master is crashed.  Terminate the master by Ctrl-C and remove the database file.</p>

<pre>[terminal-1]$ rm casket-1.tch
</pre>

<p>Terminate the slave by Ctrl-C and restart it as the new master.</p>

<pre>[terminal-2]$ ttserver -port 1979 -ulog ulog-2 -sid 2 casket-2.tch
</pre>

<p>Add the new slave (at port 1980).</p>

<pre>[terminal-1]$ mkdir ulog-3
[terminal-1]$ ttserver -port 1980 -ulog ulog-3 -sid 3 \
                -mhost localhost -mport 1979 -rts 3.rts casket-3.tch
</pre>

<p>Check consistency of stored records in the new master and the new slave.</p>

<pre>[terminal-2]$ tcrmgr mget -port 1979 localhost one two three
[terminal-2]$ tcrmgr mget -port 1980 localhost one two three
</pre>

<p>Terminate the two servers by Ctrl-C and remove the database and related files.</p>

<pre>[terminal-1]$ rm -rf casket-1.tch ulog-1 1.rts
[terminal-2]$ rm -rf casket-2.tch ulog-2 2.rts
[terminal-1]$ rm -rf casket-3.tch ulog-3 3.rts
</pre>

<p>Tokyo Tyrant supports "dual master" replication which realizes higher availability.  To do it, run two servers which replicate each other.</p>

<h3>Setting Replication on Demand</h3>

<p>You can set replication of the running database service without any downtime.  First, prepare the following script for backup operation and save it as "ttbackup.sh" with executable permission (0755).</p>

<pre>#! /bin/sh
srcpath="$1"
destpath="$1.$2"
rm -f "$destpath"
cp -f "$srcpath" "$destpath"
</pre>

<p>Next, let's run the master with update log enabled.</p>

<pre>[terminal-1]$ mkdir ulog-1
[terminal-1]$ ttserver -port 1978 -ulog ulog-1 -sid 1 casket-1.tch
</pre>

<p>Store a volume of records into the master.</p>

<pre>[terminal-2]$ tcrtest write -port 1978 localhost 10000
</pre>

<p>Check consistency of stored records.</p>

<pre>[terminal-2]$ tcrmgr list -port 1978 -pv localhost
</pre>

<p>Backup the database.</p>

<pre>[terminal-2]$ tcrmgr copy -port 1978 localhost '@./ttbackup.sh'
</pre>

<p>Confirm that the backup file was saved as "casket-1.tch.<var>xxxxx</var>" ("<var>xxxxx</var>" stands for the time stamp of the backup file).  Then, run the slave with the backup file.</p>

<pre>[terminal-2]$ ls
[terminal-2]$ cp casket-1.tch.<var>xxxxx</var> casket-2.tch
[terminal-2]$ echo <var>xxxxx</var> &gt; 2.rts
[terminal-2]$ mkdir ulog-2
[terminal-2]$ ttserver -port 1979 -ulog ulog-2 -sid 2 -rts 2.rts casket-2.tch
</pre>

<p>Note that the above operation did not specify the master server to the slave.  For tutorial, let's simulate that some records are stored into the master by users while you are setting replication.</p>

<pre>[terminal-3]$ tcrmgr put -port 1978 localhost one first
[terminal-3]$ tcrmgr put -port 1978 localhost two second
[terminal-3]$ tcrmgr put -port 1978 localhost three third
</pre>

<p>Check the difference between the master and the slave.</p>

<pre>[terminal-3]$ tcrmgr inform -port 1978 localhost
[terminal-3]$ tcrmgr inform -port 1979 localhost
</pre>

<p>Specify the master to the slave so that replication will start and the difference will be resolved.</p>

<pre>[terminal-3]$ tcrmgr setmst -port 1979 -mport 1978 localhost localhost
</pre>

<p>Confirm that the slave knows the master and the difference has been resolved.</p>

<pre>[terminal-3]$ tcrmgr inform -port 1979 -st localhost
</pre>

<p>Terminate the two servers by Ctrl-C and remove the database and related files.</p>

<pre>[terminal-1]$ rm -rf casket-1.tch casket-1.tch.* ulog-1 1.rts ttbackup.sh
[terminal-2]$ rm -rf casket-2.tch ulog-2 2.rts
</pre>

<h3>Tuning</h3>

<p>If you use a hash database, set the tuning parameter "#bnum=<var>xxx</var>" to improve performance.  It specifies the bucket number and should be more than the number of record to be stored.</p>

<p>If you use a B+ tree database, set the tuning parameters "#lcnum=<var>xxx</var>#bnum=<var>yyy</var>" to improve performance.  The former specifies the maximum number of leaf nodes to be cached.  It should be larger as long as the capacity of RAM on the system allows.  The latter specifies the bucket number and should be more than 1/128 of the number of records to be stored.</p>

<p>If huge number of clients access the server, make sure the limit number of file descriptors per a process is cleared.  By default on most systems, it is set as 1024.  If so, use `<code>ulimit</code>' to clear it.</p>

<h3>Using memcached Client</h3>

<p>This section describes how to use a memcached client library of Perl (Cache::Memcached) with Tokyo Tyrant.  Run the server of Tokyo Tyrant as usual.  And, the following script is a typical example.</p>

<pre>use Cache::Memcached;

my $memd = Cache::Memcached-&gt;new();
$memd-&gt;set_servers(['localhost:1978']);

$memd-&gt;set('one', 'first');
$memd-&gt;set('two', 'second');
$memd-&gt;set('three', 'third');

my $val = $memd-&gt;get('one');
printf('one: %s\n', $val);

$val = $memd-&gt;get_multi('one', 'two', 'three');
printf("one: %s\n", $val-&gt;{one});
printf("two: %s\n", $val-&gt;{two});
printf("three: %s\n", $val-&gt;{three});

$memd-&gt;delete('one');
</pre>

<h3>Using HTTP Client</h3>

<p>This section describes how to use an HTTP client library of Perl (LWP::UserAgent) with Tokyo Tyrant.  Run the server of Tokyo Tyrant as usual.  And, the following script is a typical example.</p>

<pre>use LWP::UserAgent;

my $ua = LWP::UserAgent-&gt;new(keep_alive =&gt; 1);
my $baseurl = 'http://localhost:1978/';

my $req;
$req = HTTP::Request-&gt;new(PUT =&gt; $baseurl . 'one', [], 'first');
$ua-&gt;request($req);
$req = HTTP::Request-&gt;new(PUT =&gt; $baseurl . 'two', [], 'second');
$ua-&gt;request($req);
$req = HTTP::Request-&gt;new(PUT =&gt; $baseurl . 'three', [], 'third');
$ua-&gt;request($req);

$req = HTTP::Request-&gt;new(GET =&gt; $baseurl . 'one');
my $res = $ua-&gt;request($req);
if($res-&gt;is_success()){
    printf("%s\n", $res-&gt;content());
}

$req = HTTP::Request-&gt;new(DELETE =&gt; $baseurl . 'one');
$ua-&gt;request($req);
</pre>

<hr />

<h2 id="license">License</h2>

<p>Tokyo Tyrant is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License or any later version.</p>

<p>Tokyo Tyrant is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.</p>

<p>You should have received a copy of the GNU Lesser General Public License along with Tokyo Tyrant (See the file `<code>COPYING</code>'); if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.</p>

<p>Tokyo Tyrant was written by Mikio Hirabayashi.  You can contact the author by e-mail to `<code>mikio@users.sourceforge.net</code>'.</p>

<hr />

</body>

</html>

<!-- END OF FILE -->
